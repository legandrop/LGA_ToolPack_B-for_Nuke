"""
_____________________________________________________________________________________________

  LGA_LC_CDL v1.0 | Lega
  No sirve para nada. Era para leer un .cc y generar un .cube. Pero es innecesario porque se puede leer el cc desde un OCIOFileTransform
_____________________________________________________________________________________________

"""

import nuke
import os


def update_ocio_cdl_nodes():
    """
    Actualiza los nodos OCIOCDLTransform seleccionados para usar archivos .cc desde la carpeta _input del proyecto
    """

    # Obtener nodos seleccionados
    selected_nodes = nuke.selectedNodes()

    # Verificar que haya nodos seleccionados
    if not selected_nodes:
        nuke.message("Debes seleccionar al menos un nodo OCIOCDLTransform.")
        return

    # Obtener la ruta del directorio del script actual
    script_path = nuke.scriptName()
    if not script_path:
        nuke.message("El script no esta guardado. Por favor guarda el script primero.")
        return

    script_directory = os.path.dirname(script_path)
    print(f"Directorio del script: {script_directory}")

    # Buscar la carpeta _input subiendo 2 niveles desde el directorio del script
    project_root = script_directory
    # Subir 2 niveles desde el directorio del script
    for _ in range(2):
        project_root = os.path.dirname(project_root)

    input_folder = os.path.join(project_root, "_input")
    print(f"Buscando carpeta _input en: {input_folder}")

    # Verificar si existe la carpeta _input
    if not os.path.exists(input_folder):
        nuke.message(f"No se encontro la carpeta _input en: {input_folder}")
        return

    # Buscar archivos .cc en la carpeta _input
    cc_files = []
    try:
        for file in os.listdir(input_folder):
            if file.lower().endswith(".cc"):
                cc_files.append(os.path.join(input_folder, file))

        if not cc_files:
            nuke.message(f"No se encontraron archivos .cc en: {input_folder}")
            return

        # Usar el primer archivo .cc encontrado
        selected_cc_file = cc_files[0]
        print(f"Usando archivo CC: {selected_cc_file}")

    except Exception as e:
        nuke.message(f"Error al buscar archivos .cc: {str(e)}")
        return

    # Contadores para el reporte
    processed_nodes = 0
    updated_nodes = 0

    # Procesar cada nodo seleccionado
    for node in selected_nodes:
        if node.Class() == "OCIOCDLTransform":
            processed_nodes += 1

            # Obtener la ruta actual del archivo
            current_file = node["file"].value()

            if current_file:
                # Actualizar el nodo con el archivo .cc encontrado
                node["file"].setValue(selected_cc_file)
                updated_nodes += 1
                print(
                    f"Nodo '{node.name()}' actualizado: {current_file} -> {selected_cc_file}"
                )
            else:
                # Si no tiene archivo, asignar el archivo .cc
                node["file"].setValue(selected_cc_file)
                updated_nodes += 1
                print(f"Nodo '{node.name()}' asignado: {selected_cc_file}")

    # Si se procesaron nodos OCIOCDLTransform exitosamente, buscar nodos GenerateLUT
    if processed_nodes > 0:
        print(
            f"OCIOCDLTransform procesados: {processed_nodes}, actualizados: {updated_nodes}"
        )

        # Crear ruta del archivo .cube basados en el .cc encontrado (sin verificar si existe)
        # Usar os.path para manejar correctamente los separadores de ruta
        file_name = os.path.basename(selected_cc_file)
        file_name_cube = file_name.replace(".cc", ".cube")
        cube_file = os.path.join(input_folder, file_name_cube)

        # NORMALIZAR la ruta para Nuke (convertir \ a /)
        cube_file_normalized = cube_file.replace("\\", "/")
        input_folder_normalized = input_folder.replace("\\", "/")

        print(f"Configurando ruta CUBE para generacion: {cube_file_normalized}")
        print(f"Archivo CC original: {selected_cc_file}")
        print(f"Directorio _input: {input_folder_normalized}")

        # Buscar nodos GenerateLUT entre los seleccionados
        generatelut_nodes = 0
        updated_generatelut = 0

        for node in selected_nodes:
            if node.Class() == "GenerateLUT":
                generatelut_nodes += 1
                # Configurar el archivo para generacion (usar ruta normalizada)
                cube_file_normalized = cube_file.replace("\\", "/")
                node["file"].setValue(cube_file_normalized)
                # Cambiar el file_type a .cube
                node["file_type"].setValue(".cube")
                updated_generatelut += 1
                print(
                    f"Nodo GenerateLUT '{node.name()}' configurado para generar: {cube_file_normalized}"
                )

                # INTENTAR ejecutar la generacion del LUT usando diferentes metodos
                try:
                    print(f"Generando LUT automaticamente para '{node.name()}'...")

                    # Metodo 1: Buscar knob de generacion (como "generate" o "write")
                    lut_generated = False
                    for knob_name in node.knobs():
                        if (
                            "generate" in knob_name.lower()
                            or "write" in knob_name.lower()
                        ):
                            try:
                                knob = node[knob_name]
                                # Los knobs no tienen execute(), intentar obtener su valor
                                try:
                                    knob_value = knob.value()
                                    print(
                                        f"Knob '{knob_name}' ejecutado - valor: {knob_value}"
                                    )
                                    lut_generated = True
                                    break
                                except Exception as knob_exec_error:
                                    print(
                                        f"No se pudo ejecutar knob '{knob_name}': {str(knob_exec_error)}"
                                    )
                            except Exception as knob_error:
                                print(
                                    f"Error con knob '{knob_name}': {str(knob_error)}"
                                )

                    # Metodo 2: Si no funciono el knob, intentar nuke.execute
                    if not lut_generated:
                        current_frame = nuke.frame()
                        nuke.execute(node, current_frame, current_frame)
                        print(
                            f"LUT generado exitosamente usando nuke.execute: {cube_file_normalized}"
                        )

                except Exception as e:
                    print(f"Error al generar LUT automaticamente: {str(e)}")
                    print(
                        f"Puede generar el LUT manualmente presionando 'Generate and Write LUT File' en el nodo '{node.name()}'"
                    )

        print(
            f"GenerateLUT procesados: {generatelut_nodes}, configurados: {updated_generatelut}"
        )

        # PASO FINAL: Buscar nodos Vectorfield y configurarles el archivo .cube generado
        if updated_generatelut > 0:
            print(f"Configurando nodos Vectorfield con el LUT generado...")

            # Buscar nodos Vectorfield entre los seleccionados
            vectorfield_nodes = 0
            updated_vectorfield = 0

            for node in selected_nodes:
                if node.Class() == "Vectorfield":
                    vectorfield_nodes += 1
                    # Configurar el archivo .cube generado
                    node["vfield_file"].setValue(cube_file_normalized)
                    # Configurar el file_type a cube
                    node["file_type"].setValue("cube")
                    updated_vectorfield += 1
                    print(
                        f"Nodo Vectorfield '{node.name()}' configurado con: {cube_file_normalized}"
                    )

            print(
                f"Vectorfield procesados: {vectorfield_nodes}, configurados: {updated_vectorfield}"
            )

            # Resumen final
            print(
                """
=== RESUMEN FINAL ==="""
            )
            print(f"OCIOCDLTransform: {updated_nodes} actualizados")
            print(f"GenerateLUT: {updated_generatelut} configurados y generados")
            print(f"Vectorfield: {updated_vectorfield} configurados")
            print(f"Archivo generado: {cube_file_normalized}")
        else:
            print("No se configuraron nodos GenerateLUT")

    else:
        print("No se procesaron nodos OCIOCDLTransform")


# Llamar a la funcion si el script se ejecuta directamente
if __name__ == "__main__":
    update_ocio_cdl_nodes()
